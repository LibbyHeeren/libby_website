{
  "hash": "8765ecb13f2f758a3759723fe84282a8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Ellsworth Project: Part 3\"\ndescription: \"Part 3 of a series documenting my learning process as I code a Shiny app that generates random artwork inspired by Ellsworth Kelly's Spectrum Colors by Chance Series\"\ndate: \"2025-06-06\"\nimage: images/00-cover-image.png\nimage-alt: \"Hand-drawn image of colors sampled from Kelly's artwork with numbers next to them that seem to be counts\"\ncategories:\n  - R\n  - Shiny\n# bibliography: references.bib\n# number-sections: true\nnumber-depth: 2\nexecute: \n  eval: false # no code chunks will evaluate, just the code will show up\ndraft: false # true prevents this from going in the listing\nformat:\n  html:\n    fig-align: center\n---\n\n\n\n------------------------------------------------------------------------\n\n## February 22nd, 2024\n\nI looked at my work from a few days before and realized I had been coding in a fugue state for the most part, and that my process documentation was abysmal. I normally document every step of development, but I had just gotten **too turnt**. I decided to not code for the day, and to instead spend it creating the documentation I shared in the first two blog posts. From this point on, I am going to document as I go. I also spent a lot of today trying to save my laptop which had been gasping its last breaths for the last 6 months. I updated my graphics drivers and defragged. Prayed. Lit a candle. Fingers crossed that my machine doesn't die again tomorrow ü§û  \n\n**Notes from now on will be written in the present tense, but are being copied over from raw work notes from last year. This means Future Libby is here with future knowledge, cringing at Past Libby and having a laugh.**  \n\n## February 23rd, 2024\n\nü•≥ Hey, my laptop didn‚Äôt crash this morning! That‚Äôs cause for celebration. I wrote some hand-written notes on how I‚Äôd like to tackle actually utilizing my probabilities. Do I want to use a sample() function and assign a vector of weights to the prob = option? I‚Äôd need to assign equal probability to all colors and then a (1-prob) probability for white (or whatever the background color is). \n\n![](images/01-color-vs-no-color.jpeg){fig-align=\"center\"}\n\nThat‚Äôs a lot of coding, and it makes it WAY harder to parameterize the colors, allowing the user to potentially choose their own colors. But, my initial idea for how to assign the colors vs the background color was actually to just start with my ‚Äúpiece VII‚Äù plot of all those random colors (minus the white and black) and then just fill in the white/background tiles.  \n\n![](images/02-random-color-grid-notes.jpeg){fig-align=\"center\"}\n\nSo, I‚Äôll try that first to see if it works out alright. I don‚Äôt think I really need to start with the full plot from my proof of concept (piece VII), I think I just need the data frame that contained my grid coordinates and my colors. I will create a script that recreates the randomly assigned color vector, but without the color white. \n\nAs far as I can tell, Kelly‚Äôs piece IV, which has a black background with a similarly clustered center of color, doesn‚Äôt feature any white as a color, but piece III, which has a white background, features black as a color. Not sure how I‚Äôll tackle this yet if I choose to offer black as a background. Here's Ellsworth's original Piece IV with the black background, for reference.  \n\n![Original photograph of Piece IV from ellsworthkelly.org](images/03-kellys-piece-IV-original.png){fig-align=\"center\"}\n\nBUT FIRST! Since I‚Äôm at the point where I‚Äôm actually writing some pieces of final code, I‚Äôd like to sample the colors from piece III again, compare them to samples from other pieces, and try to identify all unique colors. I knew when I sampled the first time that there were nuances I wasn‚Äôt picking up, but they became more apparent to me as I was carefully counting all of the colors to measure probabilities. \n\nFrom what I‚Äôve read of Kelly‚Äôs process, he used little pieces of paper with his colors written on them, drawing them from a bowl randomly. He used about 40 squares of each color and he used something like 18 unique colors (plus black and white?), perhaps based on the colors of colored paper available to him at the time in France. I decided to get more clear on the proportions of each color, especially because it seemed like there were a LOT more red/orange squares than anything else. I was in for a surprise! The most prevalent color in piece III was actually black, followed by light orange and orange, assuming I counted correctly. And, hey, I did end up with 18 colors including black (not including the white of the page which I‚Äôve labeled ‚Äúpaper‚Äù in the hex codes).\n\nHere is my original count of the colors:\n\n![](images/04-counting-color-swatches.jpeg){fig-align=\"center\"}\n\nFor my re-swatching of the colors, I did as much research as I could to find lots of different photos and videos of Kelly‚Äôs pieces. It seems likely his pieces have yellowed and faded over time, and the colors don‚Äôt look as vibrant as they probably once did. I know firsthand how much some colors can dull when exposed to light.\n\nTake a look at a still from [this video of piece II](https://www.youtube.com/watch?v=bk5em22tDXo). The green and purple colors especially look dull in this lighting. I wonder if that‚Äôs how they feel in person. Piece II is paper pasted collage. Wish I could replicate the slight jitter that comes from some pieces being just slightly smaller or larger than others, but not sure it's worth bothering about.  \n\n![Still image from a video of Piece II - sorry, this looks clickable and it's not üòÇ](images/03-5-still-from-video-of-pieces.png){fig-align=\"center\"}\n\nI decided to use [the photograph of piece III that I have from the artist‚Äôs own website](https://ellsworthkelly.org/work/spectrum-colors-arranged-by-chance/), but corrected the yellowing jussssst slightly and increased the saturation a tad to see if I could perhaps get a more true version of the colors, hopefully closer to what they originally might have looked like. \n\nWhile there is something cozy and comforting about the warm, yellowed palette of the website photograph, what I‚Äôm keeping in mind is that Kelly‚Äôs art was all about full vibrancy, and that the title of the series includes the words ‚Äúspectrum colors,‚Äù which denotes true colors of the visible spectrum of light (think ROYGBIV). I also consulted [this image of piece II](https://media.tate.org.uk/aztate-prd-ew-dg-wgtail-st1-ctr-data/images/ellsworth-kelly-spectrum_0.width-1200.jpg) from [the Tate's page about Kelly](https://www.tate.org.uk/tate-etc/issue-16-summer-2009/sixty-years-full-intensity)‚Äô, which looks like it‚Äôs been brightened. I‚Äôm not sure I like the resulting colors I ended up with, but I‚Äôm forging ahead anyway. Colors on screens will never look the same to anyone and I‚Äôm planning to let folks use their own colors anyway!  \n\n![Brightened image of Kelly's Piece III with hex codes for colors added in Snagit](images/05-kellys-piece-III-added-hexcodes.png){fig-align=\"center\"}\n\nHere is my original sampling of colors on the left compared to my new sampling of colors on the right. In the coding environment I use (the RStudio IDE), hex values get filled in as their color on the screen, making it easy to see what you‚Äôre doing. Kinda cool for this comparison!  \n\n![](images/06-hex-code-palettes-in-rstudio.png){fig-align=\"center\"}\n\nIf you‚Äôre curious, I use a color picker Chrome Extension for sampling colors. Here‚Äôs the full palette in my favorite color visualization tool, [Viz Palette](https://projects.susielu.com/viz-palette):\n\n\n\n```{=html}\n<iframe width=\"780\" height=\"500\" src=\"https://projects.susielu.com/viz-palette?colors=[%22#1a8bb3%22,%22#0950ae%22,%22#4dace5%22,%22#126ddb%22,%22#e48dc4%22,%22#aba9e8%22,%22#872791%22,%22#6d1617%22,%22#d2a1c0%22,%22#952017%22,%22#b81634%22,%22#df3b43%22,%22#e35c47%22,%22#eb8749%22,%22#f6e254%22,%22#7b442d%22,%22#000000%22,%22#1a6e7e%22,%22#7cbf7b%22,%22#add2b8%22]&backgroundColor=%22#edefee%22&fontColor=%22black%22&mode=%22normal%22\" title=\"Embedded Viz Palette\"></iframe>\n```\n\n\n\nThe next step is to finally see if my handwritten code to assign probabilities to a matrix actually works.  As a reminder, this was what I figured out:  \n\n![](images/07-reminder-quadrants-1.png){fig-align=\"center\"}\n![](images/08-reminder-quadrants-2.png){fig-align=\"center\"}\n\nSo, I‚Äôm building a matrix of probabilities based on the size of the desired grid, and I‚Äôll then join that matrix up with my data frame of colors and coordinates. First, though, I need to build the quadrant I‚Äôll use to mirror.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(tidyverse)\n\n# Define a function to generate a random vector of colors\ngenerate_color_vector <- function(size, colors) {\n\n  # Create a size^2 vector filled with a random sample of colors from a color list\n  color_vector <- sample(x = colors,\n                         size = size * size,   # \"size\" is the # of squares on each side\n                         replace = TRUE)\n\n  return(color_vector)\n}\n\n# Set the size of the desired grid and calculate number of circuits\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n            \"#1A8BB3\", # Teal - no longer teal, just bright blue\n            \"#0950AE\", # Dark blue\n            \"#4DACE5\", # Light blue\n            \"#126DDB\", # Blue\n            \"#E48DC4\", # Pink\n            \"#ABA9E8\", # Light purple\n            \"#872791\", # Purple\n            \"#6D1617\", # Dark red\n            \"#B81634\", # Red\n            \"#DF3B43\", # Red orange\n            \"#E35C47\", # Orange\n            \"#EB8749\", # Light orange\n            \"#F6E254\", # Yellow\n            \"#7B442D\", # Brown\n            \"#000000\", # Black\n            \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n            \"#7CBF7B\", # Green\n            \"#ADD2B8\") # Light green\n\n# Generate the color grid\ncolor_vector <- generate_color_vector(size, colors)\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Include my function that calculates probabilities based on circuits\n# Maybe I should make it based on size? I will already have circuits, though.\nget_prob_vector <- function(circuits){\n\n  first10perc <- seq(0, 0.02857143, length.out = round(circuits*.10)+1) # 3\n\n  last90perc_length <- circuits - length(first10perc)\n\n  last10perc_length <- round(last90perc_length * (1/9)) # 2\n\n  middle80perc_length <- last90perc_length - last10perc_length # 15\n\n  middle80perc <- seq(0.02857143, 1, length.out = middle80perc_length+2)[-c(1, middle80perc_length+2)]\n\n  last10perc <- rep(1, last10perc_length)\n\n  prob_vector <- c(first10perc, middle80perc, last10perc)\n\n  return(prob_vector)\n}\n\nprob_vector <- get_prob_vector(circuits)\n\n# Create function that builds the prob matrix\nget_prob_matrix <- function(size, prob_vector){\n\n  # Calculate quad size same way as circuits\n  quad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n  # Create empty matrix for the quad\n  M <- matrix(0, nrow = quad_size, ncol = quad_size)\n\n  # For loop to assign prob_vector to correct cells in quadrant\n  for (i in 1:quad_size){\n\n    M[i, i:quad_size] <- prob_vector[i]\n    M[i:quad_size, i] <- prob_vector[i]\n  }\n\n  # if size is even,\n  if(size %% 2 == 0){\n    # mirror horizontally and column bind\n    M_right <- apply(M, 1, rev)\n    M <- cbind(M, M_right)\n\n    # then mirror vertically and row bind\n    M_down <- apply(M, 2, rev)\n    M <- rbind(M, M_down)\n\n  }else{ # if size is odd\n    # mirror all but last col horizontally and col bind\n    M_right <- apply(M[ , 1:(quad_size-1)], 1, rev)\n    M <- cbind(M, M_right)\n\n    # then mirror all but last row vertically and row bind\n    M_down <- apply(M[1:(quad_size-1), ], 2, rev)\n    M <- rbind(M, M_down)\n\n  }\n\n  return(M)\n}\n\nM <- get_prob_matrix(size, prob_vector)\n\n\n# Apply M to df as a vector\ndf$probs <- as.vector(M)\n\n# Can I verify I did this correctly by plotting a rounded version of each\n# prob inside a tile? I asked ChatGPT to do this quickly and it came through\n\nggplot(df, aes(x = x, y = y, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n  geom_text() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank(),\n        plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n  coord_fixed()\n```\n:::\n\n\n\nYIKES. That‚Äôs not right. All the blue (the 1 values) should be clustered in the center.  \n\n![](images/09-prob-plot-not-right.png){fig-align=\"center\"}\n\nSomething has definitely gone wrong somewhere, though.. the bottom part turned out correct, so that means multiple things might have gone wrong in just the right way. I‚Äôm going to start over and do things one by one, plotting each step of the way so that I can see what‚Äôs going on.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(tidyverse)\n\n# Define a function to generate a random vector of colors\ngenerate_color_vector <- function(size, colors) {\n\n  # Create a size^2 vector filled with a random sample of colors from a color list\n  color_vector <- sample(x = colors,\n                         size = size * size,   # \"size\" is the # of squares on each side\n                         replace = TRUE)\n\n  return(color_vector)\n}\n\n# Set the size of the desired grid and calculate number of circuits\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n            \"#1A8BB3\", # Teal - no longer teal, just bright blue\n            \"#0950AE\", # Dark blue\n            \"#4DACE5\", # Light blue\n            \"#126DDB\", # Blue\n            \"#E48DC4\", # Pink\n            \"#ABA9E8\", # Light purple\n            \"#872791\", # Purple\n            \"#6D1617\", # Dark red\n            \"#B81634\", # Red\n            \"#DF3B43\", # Red orange\n            \"#E35C47\", # Orange\n            \"#EB8749\", # Light orange\n            \"#F6E254\", # Yellow\n            \"#7B442D\", # Brown\n            \"#000000\", # Black\n            \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n            \"#7CBF7B\", # Green\n            \"#ADD2B8\") # Light green\n\n# Generate the color grid\ncolor_vector <- generate_color_vector(size, colors)\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Include my function that calculates probabilities based on circuits\n# Maybe I should make it based on size? I will already have circuits, though.\nget_prob_vector <- function(circuits){\n\n  first10perc <- seq(0, 0.02857143, length.out = round(circuits*.10)+1) # 3\n\n  last90perc_length <- circuits - length(first10perc)\n\n  last10perc_length <- round(last90perc_length * (1/9)) # 2\n\n  middle80perc_length <- last90perc_length - last10perc_length # 15\n\n  middle80perc <- seq(0.02857143, 1, length.out = middle80perc_length+2)[-c(1, middle80perc_length+2)]\n\n  last10perc <- rep(1, last10perc_length)\n\n  prob_vector <- c(first10perc, middle80perc, last10perc)\n\n  return(prob_vector)\n}\n\nprob_vector <- get_prob_vector(circuits)\n\n# Create function that builds the prob matrix\n```\n:::\n\n\n\nOk, this is where I‚Äôm going to start iterating to diagnose.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Create empty matrix for the quad\nM <- matrix(0, nrow = quad_size, ncol = quad_size)\n\n# Plot the empty matrix\ngrid_data <- expand.grid(row = 1:20, col = 1:20)\ngrid_data$probs <- as.vector(M)\n\nggplot(grid_data, aes(x = col, y = row, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n  geom_text() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank(),\n        plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n  coord_fixed()\n```\n:::\n\n\n\n![](images/10-prob-plot-all-zeroes.png){fig-align=\"center\"}\n\nLooks good. Next step, create the initial quadrant. Going to switch to using reshape2::melt() for reshaping my matrix M into a vector. I just like it better than as.vector.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For loop to assign prob_vector to correct cells in quadrant\nfor (i in 1:quad_size){\n\n  M[i, i:quad_size] <- prob_vector[i]\n  M[i:quad_size, i] <- prob_vector[i]\n}\n\n# Plot again\n\ngrid_data <- expand.grid(row = 1:20, col = 1:20)\n> grid_data[1:30, ]\n    row col\n1     1   1\n2     2   1\n3     3   1\n4     4   1\n5     5   1\n6     6   1\n7     7   1\n8     8   1\n9     9   1\n10   10   1\n11   11   1\n12   12   1\n13   13   1\n14   14   1\n15   15   1\n16   16   1\n17   17   1\n18   18   1\n19   19   1\n20   20   1\n21    1   2\n22    2   2\n23    3   2\n24    4   2\n25    5   2\n26    6   2\n27    7   2\n28    8   2\n29    9   2\n30   10   2\n# This looks right\n\nprobs_df <- reshape2::melt(M)\n> probs_df[1:25, ]\n    Var1 Var2      value\n1      1    1 0.00000000\n2      2    1 0.00000000\n3      3    1 0.00000000\n4      4    1 0.00000000\n5      5    1 0.00000000\n6      6    1 0.00000000\n7      7    1 0.00000000\n8      8    1 0.00000000\n9      9    1 0.00000000\n10    10    1 0.00000000\n11    11    1 0.00000000\n12    12    1 0.00000000\n13    13    1 0.00000000\n14    14    1 0.00000000\n15    15    1 0.00000000\n16    16    1 0.00000000\n17    17    1 0.00000000\n18    18    1 0.00000000\n19    19    1 0.00000000\n20    20    1 0.00000000\n21     1    2 0.00000000\n22     2    2 0.01428571\n23     3    2 0.01428571\n24     4    2 0.01428571\n25     5    2 0.01428571\n# This looks right\n\ngrid_data$probs <- reshape2::melt(M)[, 3]\n> grid_data[1:30, ]\n   row col      probs\n1    1   1 0.00000000\n2    2   1 0.00000000\n3    3   1 0.00000000\n4    4   1 0.00000000\n5    5   1 0.00000000\n6    6   1 0.00000000\n7    7   1 0.00000000\n8    8   1 0.00000000\n9    9   1 0.00000000\n10  10   1 0.00000000\n11  11   1 0.00000000\n12  12   1 0.00000000\n13  13   1 0.00000000\n14  14   1 0.00000000\n15  15   1 0.00000000\n16  16   1 0.00000000\n17  17   1 0.00000000\n18  18   1 0.00000000\n19  19   1 0.00000000\n20  20   1 0.00000000\n21   1   2 0.00000000\n22   2   2 0.01428571\n23   3   2 0.01428571\n24   4   2 0.01428571\n25   5   2 0.01428571\n26   6   2 0.01428571\n27   7   2 0.01428571\n28   8   2 0.01428571\n29   9   2 0.01428571\n30  10   2 0.01428571\n# This looks right\n\nggplot(grid_data, aes(x = col, y = row, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n  geom_text() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank(),\n        plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n  coord_fixed()\n# But this is wrong\n```\n:::\n\n\n\n![](images/11-prob-plot-quad-wrong-again.png){fig-align=\"center\"}\n\nAlright, this is definitely not correct, but why? I‚Äôve definitely got something wrong. I‚Äôm going to inspect my for loop used to assign probabilities to the quad matrix.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:quad_size){\n\n  M[i, i:quad_size] <- prob_vector[i] # row 1, columns 1:20\n  M[i:quad_size, i] <- prob_vector[i] # col 1, rows 1:20\n}\n\n# So, M[1,1] should be 0 and M[20,20] should be 1\n# > M[1,1]\n# [1] 0\n# > M[20,20]\n# [1] 1\n\n# And they are\n\n# Column 20 should be probs from 0 to 1\n# > M[, 20]\n#  [1] 0.00000000 0.01428571 0.02857143\n#  [4] 0.08928572 0.15000000 0.21071429\n#  [7] 0.27142857 0.33214286 0.39285714\n# [10] 0.45357143 0.51428571 0.57500000\n# [13] 0.63571429 0.69642857 0.75714286\n# [16] 0.81785714 0.87857143 0.93928571\n# [19] 1.00000000 1.00000000\n\n# And it is\n```\n:::\n\n\n\nI‚Äôm going to do a minimally viable example creating a simple matrix, melting it, and then plotting it using geom_tile to see what it looks like.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:25, nrow = 5, ncol = 5)\nm\n#      [,1] [,2] [,3] [,4] [,5]\n# [1,]    1    6   11   16   21\n# [2,]    2    7   12   17   22\n# [3,]    3    8   13   18   23\n# [4,]    4    9   14   19   24\n# [5,]    5   10   15   20   25\n\ngrid_data_test <- expand.grid(row = 1:5, col = 1:5)\n\ngrid_data_test\n#    row col\n# 1    1   1\n# 2    2   1\n# 3    3   1\n# 4    4   1\n# 5    5   1\n# 6    1   2\n# 7    2   2\n# 8    3   2\n# 9    4   2\n# 10   5   2\n# 11   1   3\n# 12   2   3\n# 13   3   3\n# 14   4   3\n# 15   5   3\n# 16   1   4\n# 17   2   4\n# 18   3   4\n# 19   4   4\n# 20   5   4\n# 21   1   5\n# 22   2   5\n# 23   3   5\n# 24   4   5\n# 25   5   5\n\ngrid_data_test$probs <- reshape2::melt(m)[, 3]\n\ngrid_data_test\n#    row col probs\n# 1    1   1     1\n# 2    2   1     2\n# 3    3   1     3\n# 4    4   1     4\n# 5    5   1     5\n# 6    1   2     6\n# 7    2   2     7\n# 8    3   2     8\n# 9    4   2     9\n# 10   5   2    10\n# 11   1   3    11\n# 12   2   3    12\n# 13   3   3    13\n# 14   4   3    14\n# 15   5   3    15\n# 16   1   4    16\n# 17   2   4    17\n# 18   3   4    18\n# 19   4   4    19\n# 20   5   4    20\n# 21   1   5    21\n# 22   2   5    22\n# 23   3   5    23\n# 24   4   5    24\n# 25   5   5    25\n\n# Plot\nggplot(grid_data_test, aes(x = col, y = row, label = round(probs, 2))) +\n  # geom_tile(aes(fill = probs), colour = \"white\") +\n  geom_text() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank(),\n        plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n  coord_fixed()\n```\n:::\n\n\n\n![](images/12-ggplot-grid-number-test.png){fig-align=\"center\"}\n\nOK WHAT THE HECK, GGPLOT. I thought I knew what was up. I thought my x and y were flipped and I was calling x the row and y the col (which I probably am still doing somewhere), but this is definitely happening somewhere within the ggplot code‚Ä¶ probably‚Ä¶ and I can‚Äôt figure it out. Don‚Äôt code tired, Libby, you're missing something super simple.  \n\n[**Note from Future Libby: Oh, goodness. This is hard to watch. THINK ABOUT HOW GGPLOT MAKES PLOTS.**]\n\nHope you've enjoyed the chaos! I'll link [the fourth part in the series here](../2025-06-07_ellsworth-part-4/index.qmd) once it's added.  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}