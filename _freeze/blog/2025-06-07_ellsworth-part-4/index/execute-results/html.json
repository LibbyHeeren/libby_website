{
  "hash": "8ab3d57464198b27f184366f17f78d9c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Ellsworth Project: Part 4\"\ndescription: \"Documenting the creation of <a href='https://libbyheeren-ellsworth.share.connect.posit.cloud/'>The Ellsworth App</a>, in which I figure out why my probability mapping is wonky in my plots.\"\ndate: \"2025-06-07\"\nimage: images/00-cover-image.png\nimage-alt: \"A ggplot of a grid with cells in the center colored blue, representing probabilities aproaching 1, and the outer cells fading to white, representing probabilities approaching 0.\"\ncategories:\n  - R\n  - Shiny\n# bibliography: references.bib\n# number-sections: true\nnumber-depth: 2\nexecute: \n  eval: false # no code chunks will evaluate, just the code will show up\ndraft: false # true prevents this from going in the listing\nformat:\n  html:\n    fig-align: center\n---\n\n\n\n------------------------------------------------------------------------\n\n## February 24th, 2024\n\nVery little chance to code today, but now that I know whatâ€™s up, maybe I can make some quick changes and go to bed happy? Iâ€™m creating a matrix correctly, everything looks right before and after I melt it. Why is ggplot reversing the order that my columns are plotting? Itâ€™s getting everything else right, just reversing the order of each column. And I commented out the geom_tile call yesterday, so itâ€™s not geom_tile itself. How else can I test this? I need to plot without the theming.  \n\n[**Note from Future Libby: Y'all, she is gonna feel so silly in a minute, just watch.**]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:25, nrow = 5, ncol = 5)\nm\n#      [,1] [,2] [,3] [,4] [,5]\n# [1,]    1    6   11   16   21\n# [2,]    2    7   12   17   22\n# [3,]    3    8   13   18   23\n# [4,]    4    9   14   19   24\n# [5,]    5   10   15   20   25\n\ngrid_data_test <- expand.grid(row = 1:5, col = 1:5)\n\ngrid_data_test\n#    row col\n# 1    1   1\n# 2    2   1\n# 3    3   1\n# 4    4   1\n# 5    5   1\n# 6    1   2\n# 7    2   2\n# 8    3   2\n# 9    4   2\n# 10   5   2\n# 11   1   3\n# 12   2   3\n# 13   3   3\n# 14   4   3\n# 15   5   3\n# 16   1   4\n# 17   2   4\n# 18   3   4\n# 19   4   4\n# 20   5   4\n# 21   1   5\n# 22   2   5\n# 23   3   5\n# 24   4   5\n# 25   5   5\n\ngrid_data_test$probs <- reshape2::melt(m)[, 3]\ngrid_data_test\n#    row col probs\n# 1    1   1     1\n# 2    2   1     2\n# 3    3   1     3\n# 4    4   1     4\n# 5    5   1     5\n# 6    1   2     6\n# 7    2   2     7\n# 8    3   2     8\n# 9    4   2     9\n# 10   5   2    10\n# 11   1   3    11\n# 12   2   3    12\n# 13   3   3    13\n# 14   4   3    14\n# 15   5   3    15\n# 16   1   4    16\n# 17   2   4    17\n# 18   3   4    18\n# 19   4   4    19\n# 20   5   4    20\n# 21   1   5    21\n# 22   2   5    22\n# 23   3   5    23\n# 24   4   5    24\n# 25   5   5    25\n\n# Plot\nggplot(grid_data_test, aes(x = col, y = row, label = round(probs, 2))) +\n  geom_text()\n```\n:::\n\n\n\n![](images/01-plotting-with-axes-finally.png){fig-align=\"center\"}\n\nOMG DUHHHHH, **of course the axes go from 0 in the bottom left corner**! Itâ€™s not reversing it, Iâ€™m the one *NOT* reversing the axes! Thatâ€™s why the columns are in order and the rows are just backwards. Ok, SHEW. Yeah, donâ€™t code tired, Libby. That was dumb ðŸ˜‚ Let me do this again, without the Tired Libby mistakes.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(grid_data_test, aes(x = col, y = row, label = round(probs, 2))) +\n    geom_text() +\n\t\tscale_y_reverse() +\n\t\tcoord_fixed()\n```\n:::\n\n\n\n![](images/02-plotting-with-axes-test-2.png){fig-align=\"center\"}\n\nYAAAAAAAAS.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(tidyverse)\n\n# Define a function to generate a random vector of colors\ngenerate_color_vector <- function(size, colors) {\n\n  # Create a size^2 vector filled with a random sample of colors from a color list\n  color_vector <- sample(x = colors,\n                         size = size * size,   # \"size\" is the # of squares on each side\n                         replace = TRUE)\n\n  return(color_vector)\n}\n\n# Set the size of the desired grid and calculate number of circuits\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n            \"#1A8BB3\", # Teal - no longer teal, just bright blue\n            \"#0950AE\", # Dark blue\n            \"#4DACE5\", # Light blue\n            \"#126DDB\", # Blue\n            \"#E48DC4\", # Pink\n            \"#ABA9E8\", # Light purple\n            \"#872791\", # Purple\n            \"#6D1617\", # Dark red\n            \"#B81634\", # Red\n            \"#DF3B43\", # Red orange\n            \"#E35C47\", # Orange\n            \"#EB8749\", # Light orange\n            \"#F6E254\", # Yellow\n            \"#7B442D\", # Brown\n            \"#000000\", # Black\n            \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n            \"#7CBF7B\", # Green\n            \"#ADD2B8\") # Light green\n\n# Generate the color grid\ncolor_vector <- generate_color_vector(size, colors)\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Include my function that calculates probabilities based on circuits\n# Maybe I should make it based on size? I will already have circuits, though.\nget_prob_vector <- function(circuits){\n\n  first10perc <- seq(0, 0.02857143, length.out = round(circuits*.10)+1) # 3\n\n  last90perc_length <- circuits - length(first10perc)\n\n  last10perc_length <- round(last90perc_length * (1/9)) # 2\n\n  middle80perc_length <- last90perc_length - last10perc_length # 15\n\n  middle80perc <- seq(0.02857143, 1, length.out = middle80perc_length+2)[-c(1, middle80perc_length+2)]\n\n  last10perc <- rep(1, last10perc_length)\n\n  prob_vector <- c(first10perc, middle80perc, last10perc)\n\n  return(prob_vector)\n}\n\nprob_vector <- get_prob_vector(circuits)\n\n# Create function that builds the prob matrix\nget_prob_matrix <- function(size, prob_vector){\n\n  # Calculate quad size same way as circuits\n  quad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n  # Create empty matrix for the quad\n  M <- matrix(0, nrow = quad_size, ncol = quad_size)\n\n  # For loop to assign prob_vector to correct cells in quadrant\n  for (i in 1:quad_size){\n\n    M[i, i:quad_size] <- prob_vector[i]\n    M[i:quad_size, i] <- prob_vector[i]\n  }\n\n  # if size is even,\n  if(size %% 2 == 0){\n    # mirror horizontally and column bind\n    M_right <- apply(M, 1, rev)\n    M <- cbind(M, M_right)\n\n    # then mirror vertically and row bind\n    M_down <- apply(M, 2, rev)\n    M <- rbind(M, M_down)\n\n  }else{ # if size is odd\n    # mirror all but last col horizontally and col bind\n    M_right <- apply(M[ , 1:(quad_size-1)], 1, rev)\n    M <- cbind(M, M_right)\n\n    # then mirror all but last row vertically and row bind\n    M_down <- apply(M[1:(quad_size-1), ], 2, rev)\n    M <- rbind(M, M_down)\n\n  }\n\n  return(M)\n}\n\nM <- get_prob_matrix(size, prob_vector)\n\n\n# Apply M to df as a vector\ndf$probs <- as.vector(M)\n\n# Plot, but make sure the y axis is reversed\n\nggplot(df, aes(x = x, y = y, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n    geom_text() +\n\t\tscale_y_reverse() +\n    scale_fill_gradient(low = \"white\", high = \"blue\") +\n    theme_minimal() +\n    theme(axis.text = element_blank(),\n          axis.title = element_blank(),\n          panel.grid = element_blank(),\n          plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n    coord_fixed()\n```\n:::\n\n\n\n![](images/03-a-different-incorrect-plot-but-progress.png){fig-align=\"center\"}\n\nThatâ€™s progress, baybeeeee! Now that I know my axes are going in the right directions, I can focus on where I think the *actual* problem is happening, which is in the flipping and binding of the matrices. Iâ€™m going to make a minimum viable example to test that function and see whatâ€™s going on at each step.\n\nThis is the guts of the function that takes the quadrant M and flips it horizontally, then cbinds it, then flips that vertically and rbinds that. Maybe Iâ€™m getting the arguments wrong and mixing things up. Lemme see what each thing is doing.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# smol zample\nsize <- 12\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# This is a test, so I'm gonna use a smaller prob_vector, too\nprob_vector <- get_prob_vector(circuits)\n\n# Calculate quad size same way as circuits\nquad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Create empty matrix for the quad\nM <- matrix(0, nrow = quad_size, ncol = quad_size)\n\nM\n#      [,1] [,2] [,3] [,4] [,5] [,6]\n# [1,]    0    0    0    0    0    0\n# [2,]    0    0    0    0    0    0\n# [3,]    0    0    0    0    0    0\n# [4,]    0    0    0    0    0    0\n# [5,]    0    0    0    0    0    0\n# [6,]    0    0    0    0    0    0\n\n# For loop to assign prob_vector to correct cells in quadrant\nfor (i in 1:quad_size){\n\n  M[i, i:quad_size] <- prob_vector[i]\n  M[i:quad_size, i] <- prob_vector[i]\n}\n\nround(M, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6]\n# [1,]    0 0.00 0.00 0.00 0.00 0.00\n# [2,]    0 0.03 0.03 0.03 0.03 0.03\n# [3,]    0 0.03 0.22 0.22 0.22 0.22\n# [4,]    0 0.03 0.22 0.42 0.42 0.42\n# [5,]    0 0.03 0.22 0.42 0.61 0.61\n# [6,]    0 0.03 0.22 0.42 0.61 0.81\n\n# ^ Wow, good to know my prob_vector is failing at this small size. Should have known.\n# I can add a condition for that later.\n\n# mirror horizontally and column bind\n  M_right <- apply(M, 1, rev)\n  \nround(M_right, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6]\n# [1,]    0 0.03 0.22 0.42 0.61 0.81\n# [2,]    0 0.03 0.22 0.42 0.61 0.61\n# [3,]    0 0.03 0.22 0.42 0.42 0.42\n# [4,]    0 0.03 0.22 0.22 0.22 0.22\n# [5,]    0 0.03 0.03 0.03 0.03 0.03\n# [6,]    0 0.00 0.00 0.00 0.00 0.00\n\n# ah hah! It's mirroring it up-down, not left-right.\n# in apply(), 1 indicates rows, 2 indicates columns, so I just got the argument wrong.\n# I need to reverse the columns, not the rows, in order to mirror it horizontally\n \n# Try that again with the right arg\nM_right <- apply(M, 2, rev)\n\nround(M_right, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6]\n# [1,]    0 0.03 0.22 0.42 0.61 0.81\n# [2,]    0 0.03 0.22 0.42 0.61 0.61\n# [3,]    0 0.03 0.22 0.42 0.42 0.42\n# [4,]    0 0.03 0.22 0.22 0.22 0.22\n# [5,]    0 0.03 0.03 0.03 0.03 0.03\n# [6,]    0 0.00 0.00 0.00 0.00 0.00\n\n# Ok, wait. What? The result of apply(M, 2, rev) and apply(M, 1, rev) are the same?\ntest1 <- round(apply(M, 1, rev), 2)\ntest2 <- round(apply(M, 2, rev), 2)\n\nidentical(test1, test2)\n# [1] TRUE\n\n# Great. That means I have just been wasting time with rev :D Should have used pracma!\n```\n:::\n\n\n\nWomp womp. Why didnâ€™t I use pracma or raster to begin with? I wasnâ€™t mirroring in the way I thought I was ðŸ˜‚ Iâ€™m gonna test pracma::flipud and fliplr (which I think stand for flip up down and flip left right).  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pracma)\n\n# smol zample, but larger than 12, let's test 16\nsize <- 16\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# This is a test, so I'm gonna use a smaller prob_vector, too\nprob_vector <- get_prob_vector(circuits)\n\n# Calculate quad size same way as circuits\nquad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Create empty matrix for the quad\nM <- matrix(0, nrow = quad_size, ncol = quad_size)\nM\n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n# [1,]    0    0    0    0    0    0    0    0\n# [2,]    0    0    0    0    0    0    0    0\n# [3,]    0    0    0    0    0    0    0    0\n# [4,]    0    0    0    0    0    0    0    0\n# [5,]    0    0    0    0    0    0    0    0\n# [6,]    0    0    0    0    0    0    0    0\n# [7,]    0    0    0    0    0    0    0    0\n# [8,]    0    0    0    0    0    0    0    0\n\n# For loop to assign prob_vector to correct cells in quadrant\nfor (i in 1:quad_size){\n\n  M[i, i:quad_size] <- prob_vector[i]\n  M[i:quad_size, i] <- prob_vector[i]\n}\n\nround(M, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n# [1,]    0 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n# [2,]    0 0.03 0.03 0.03 0.03 0.03 0.03 0.03\n# [3,]    0 0.03 0.19 0.19 0.19 0.19 0.19 0.19\n# [4,]    0 0.03 0.19 0.35 0.35 0.35 0.35 0.35\n# [5,]    0 0.03 0.19 0.35 0.51 0.51 0.51 0.51\n# [6,]    0 0.03 0.19 0.35 0.51 0.68 0.68 0.68\n# [7,]    0 0.03 0.19 0.35 0.51 0.68 0.84 0.84\n# [8,]    0 0.03 0.19 0.35 0.51 0.68 0.84 1.00\n\n# ^ prob vector function is mostly ok at this size, but this may be as small as\n# I can go. Maybe I can create a series of plots to test visually once I'm done,\n# then use the results for my conditionals on size instead of limiting\n# the function itself.\n\n# mirror horizontally and column bind\nM_right <- pracma::fliplr(M)\n\nround(M_right, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n# [1,] 0.00 0.00 0.00 0.00 0.00 0.00 0.00    0\n# [2,] 0.03 0.03 0.03 0.03 0.03 0.03 0.03    0\n# [3,] 0.19 0.19 0.19 0.19 0.19 0.19 0.03    0\n# [4,] 0.35 0.35 0.35 0.35 0.35 0.19 0.03    0\n# [5,] 0.51 0.51 0.51 0.51 0.35 0.19 0.03    0\n# [6,] 0.68 0.68 0.68 0.51 0.35 0.19 0.03    0\n# [7,] 0.84 0.84 0.68 0.51 0.35 0.19 0.03    0\n# [8,] 1.00 0.84 0.68 0.51 0.35 0.19 0.03    0\n```\n:::\n\n\n\nThat looksâ€¦ right O_O **omgomgomg**. Lemme test the `flipud()` part. Gotta finish binding that first set of matrices, though.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- cbind(M, M_right)\n\nround(M, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16]\n# [1,]    0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00  0.00  0.00  0.00  0.00  0.00  0.00     0\n# [2,]    0 0.03 0.03 0.03 0.03 0.03 0.03 0.03 0.03  0.03  0.03  0.03  0.03  0.03  0.03     0\n# [3,]    0 0.03 0.19 0.19 0.19 0.19 0.19 0.19 0.19  0.19  0.19  0.19  0.19  0.19  0.03     0\n# [4,]    0 0.03 0.19 0.35 0.35 0.35 0.35 0.35 0.35  0.35  0.35  0.35  0.35  0.19  0.03     0\n# [5,]    0 0.03 0.19 0.35 0.51 0.51 0.51 0.51 0.51  0.51  0.51  0.51  0.35  0.19  0.03     0\n# [6,]    0 0.03 0.19 0.35 0.51 0.68 0.68 0.68 0.68  0.68  0.68  0.51  0.35  0.19  0.03     0\n# [7,]    0 0.03 0.19 0.35 0.51 0.68 0.84 0.84 0.84  0.84  0.68  0.51  0.35  0.19  0.03     0\n# [8,]    0 0.03 0.19 0.35 0.51 0.68 0.84 1.00 1.00  0.84  0.68  0.51  0.35  0.19  0.03     0\n\n# Looks promising!\n\nM_down <- pracma::flipud(M)\n\nround(M_down, 2)\n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16]\n# [1,]    0 0.03 0.19 0.35 0.51 0.68 0.84 1.00 1.00  0.84  0.68  0.51  0.35  0.19  0.03     0\n# [2,]    0 0.03 0.19 0.35 0.51 0.68 0.84 0.84 0.84  0.84  0.68  0.51  0.35  0.19  0.03     0\n# [3,]    0 0.03 0.19 0.35 0.51 0.68 0.68 0.68 0.68  0.68  0.68  0.51  0.35  0.19  0.03     0\n# [4,]    0 0.03 0.19 0.35 0.51 0.51 0.51 0.51 0.51  0.51  0.51  0.51  0.35  0.19  0.03     0\n# [5,]    0 0.03 0.19 0.35 0.35 0.35 0.35 0.35 0.35  0.35  0.35  0.35  0.35  0.19  0.03     0\n# [6,]    0 0.03 0.19 0.19 0.19 0.19 0.19 0.19 0.19  0.19  0.19  0.19  0.19  0.19  0.03     0\n# [7,]    0 0.03 0.03 0.03 0.03 0.03 0.03 0.03 0.03  0.03  0.03  0.03  0.03  0.03  0.03     0\n# [8,]    0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00  0.00  0.00  0.00  0.00  0.00  0.00     0\n\nM <- rbind(M, M_down)\n\ngrid_data_smol <- expand.grid(row = 1:16, col = 1:16)\ngrid_data_smol$probs <- as.vector(M) # why did I leave you, as.vector? #base4lyfe\n\nggplot(grid_data_smol, aes(x = col, y = row, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n  geom_text() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank(),\n        plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n  coord_fixed()\n```\n:::\n\n\n\n![](images/04-we-did-it-fam.png){fig-align=\"center\"}\n\nðŸ˜­ I AM SO HAPPY! AGAIN!  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(tidyverse)\nlibrary(pracma)\n\n# Define a function to generate a random vector of colors\ngenerate_color_vector <- function(size, colors) {\n\n  # Create a size^2 vector filled with a random sample of colors from a color list\n  color_vector <- sample(x = colors,\n                         size = size * size,   # \"size\" is the # of squares on each side\n                         replace = TRUE)\n\n  return(color_vector)\n}\n\n# Set the size of the desired grid and calculate number of circuits\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n            \"#1A8BB3\", # Teal - no longer teal, just bright blue\n            \"#0950AE\", # Dark blue\n            \"#4DACE5\", # Light blue\n            \"#126DDB\", # Blue\n            \"#E48DC4\", # Pink\n            \"#ABA9E8\", # Light purple\n            \"#872791\", # Purple\n            \"#6D1617\", # Dark red\n            \"#B81634\", # Red\n            \"#DF3B43\", # Red orange\n            \"#E35C47\", # Orange\n            \"#EB8749\", # Light orange\n            \"#F6E254\", # Yellow\n            \"#7B442D\", # Brown\n            \"#000000\", # Black\n            \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n            \"#7CBF7B\", # Green\n            \"#ADD2B8\") # Light green\n\n# Generate the color grid\ncolor_vector <- generate_color_vector(size, colors)\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Include my function that calculates probabilities based on circuits\n# Maybe I should make it based on size? I will already have circuits, though.\nget_prob_vector <- function(circuits){\n\n  first10perc <- seq(0, 0.02857143, length.out = round(circuits*.10)+1) # 3\n\n  last90perc_length <- circuits - length(first10perc)\n\n  last10perc_length <- round(last90perc_length * (1/9)) # 2\n\n  middle80perc_length <- last90perc_length - last10perc_length # 15\n\n  middle80perc <- seq(0.02857143, 1, length.out = middle80perc_length+2)[-c(1, middle80perc_length+2)]\n\n  last10perc <- rep(1, last10perc_length)\n\n  prob_vector <- c(first10perc, middle80perc, last10perc)\n\n  return(prob_vector)\n}\n\nprob_vector <- get_prob_vector(circuits)\n\n# Create function that builds the prob matrix\nget_prob_matrix <- function(size, prob_vector){\n\n  # Calculate quad size same way as circuits\n  quad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n  # Create empty matrix for the quad\n  M <- matrix(0, nrow = quad_size, ncol = quad_size)\n\n  # For loop to assign prob_vector to correct cells in quadrant\n  for (i in 1:quad_size){\n\n    M[i, i:quad_size] <- prob_vector[i]\n    M[i:quad_size, i] <- prob_vector[i]\n  }\n\n  # if quad_size is even,\n  if(quad_size %% 2 == 0){\n    # mirror horizontally and column bind\n    M_right <- pracma::fliplr(M)\n    M <- cbind(M, M_right)\n\n    # then mirror vertically and row bind\n    M_down <- pracma::flipud(M)\n    M <- rbind(M, M_down)\n\n  }else{ # if quad_size is odd\n    # mirror all but last col horizontally and col bind\n    M_right <- pracma::fliplr(M[ , 1:(quad_size-1)])\n    M <- cbind(M, M_right)\n\n    # then mirror all but last row vertically and row bind\n    M_down <- pracma::flipud(M[1:(quad_size-1), ])\n    M <- rbind(M, M_down)\n\n  }\n\n  return(M)\n}\n\nM <- get_prob_matrix(size, prob_vector)\n\n\n# Apply M to df as a vector\ndf$probs <- as.vector(M)\n\n# Plot, but make sure the y axis is reversed\n\nggplot(df, aes(x = x, y = y, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n    geom_text() +\n    scale_fill_gradient(low = \"white\", high = \"blue\") +\n\t\tscale_y_reverse() +\n    theme_minimal() +\n    theme(axis.text = element_blank(),\n          axis.title = element_blank(),\n          panel.grid = element_blank(),\n          plot.margin = margin(1, 1, 1, 1, \"cm\")) +\n    coord_fixed()\n```\n:::\n\n\n\n![](images/05-drunk-with-power.png){fig-align=\"center\"}\n\n**Can you even handle it?!?** Does it work on an odd-sized grid, too? Gonna test at size 25, which will be an odd-sized grid overall, and will also have an odd-sized quad of 13.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the size of the desired grid and calculate number of circuits\nsize <- 25\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Generate the color grid\ncolor_vector <- generate_color_vector(size, colors)\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Get the prob vector\nprob_vector <- get_prob_vector(circuits)\n\n# Get the prob matrix\nM <- get_prob_matrix(size, prob_vector)\n\n# Apply M to df as a vector\ndf$probs <- as.vector(M)\n\n# Plot, but make sure the y axis is reversed\n\nggplot(df, aes(x = x, y = y, label = round(probs, 2))) +\n  geom_tile(aes(fill = probs), colour = \"white\") +\n    geom_text() +\n    scale_fill_gradient(low = \"white\", high = \"blue\") +\n\t\tscale_y_reverse() +\n    theme_void() +\n    coord_fixed()\n```\n:::\n\n\n\n![](images/06-odd-sized-grid-success.png){fig-align=\"center\"}\n\nOk ðŸ˜Œ Now I can go to bed happy. And before midnight! ðŸ˜´ Next up is trying to map these probabilities to random samples of colors, and my initial idea for that is to recreate the Piece VII random grid and then use a sample function and a random function to assign background-color squares in the negative space using 1-prob. The random number is to compare to the prob. If itâ€™s below (or above, whatever I want), then it will assign a white square. If not, it will do nothing. I guess using `case_when()`. Or something. Iâ€™ll write it out tomorrow. BED!\n\n[**Note from Future Libby: Gosh, I love her. Look at that wonder and enthusiasm. This is the best.**]\n\nI don't know why you're still reading this, but if you are, I'll link [the fifth post in the series here](../2025-06-08_ellsworth-part-5/index.qmd), and here's [the app in its current form](https://libbyheeren-ellsworth.share.connect.posit.cloud/) if you'd like to play with it!.  ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}