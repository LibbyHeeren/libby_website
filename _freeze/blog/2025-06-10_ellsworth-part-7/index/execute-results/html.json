{
  "hash": "60933564857f4821ef48a24838e3b984",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Ellsworth Project: Part 7\"\ndescription: \"Documenting the creation of <a href='https://libbyheeren-ellsworth.share.connect.posit.cloud/'>The Ellsworth App</a>, in which I finish the paint-by-numbers plot and the swatch plot.\"\ndate: \"2025-06-10\"\nimage: images/00-cover-image.png\nimage-alt: \"a plot of a 40 by 40 grid with some squares filled with colors and some not. The unfilled squares have a B in them and the filled squares have numbers in them, one number for each unique color.\"\ncategories:\n  - R\n  - Shiny\n# bibliography: references.bib\n# number-sections: true\nnumber-depth: 2\nexecute: \n  eval: false # no code chunks will evaluate, just the code will show up\ndraft: false # true prevents this from going in the listing\nformat:\n  html:\n    fig-align: center\n---\n\n\n\n------------------------------------------------------------------------\n\n## March 1st, 2024  \n\nWorking on the paint-by-numbers plot today, or ‚Äúpbn plot‚Äù as I‚Äôve begun calling it. I need to assign a number to each color and then add a column to the data frame that I am plotting that contains those numbers as strings, and then I need to print them within tiles as `geom_text` or something.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(pracma)\n\nsource(\"R/01-functions.R\")\n\n# Define the size of the piece\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Define the colors\nbackground <- \"#EDEFEE\"\ncolors <- c(#\"#EDEFEE\", # Paper\n            \"#1A8BB3\", # Teal - no longer teal, just bright blue\n            \"#0950AE\", # Dark blue\n            \"#4DACE5\", # Light blue\n            \"#126DDB\", # Blue\n            \"#E48DC4\", # Pink\n            \"#ABA9E8\", # Light purple\n            \"#872791\", # Purple\n            \"#6D1617\", # Dark red\n            \"#B81634\", # Red\n            \"#DF3B43\", # Red orange\n            \"#E35C47\", # Orange\n            \"#EB8749\", # Light orange\n            \"#F6E254\", # Yellow\n            \"#7B442D\", # Brown\n            \"#000000\", # Black\n            \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n            \"#7CBF7B\", # Green\n            \"#ADD2B8\") # Light green\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Get the vector of probabilities based on the size of the piece\nprob_vector <- get_prob_vector(circuits)\n\n# Generate the color vector\ncolor_vector <- get_color_vector(size, colors)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Assign probabilities to matrix correctly\nM <- get_prob_matrix(size, prob_vector)\n\n# Apply prob matrix M to df as a vector\ndf$probs <- as.vector(M)\n\n# Turn the piece VII vector into the piece III vector (white squares)\nfinal_df <- get_kelly_III_vector(df, background)\n\n#####################################################################\n# Add numbers to the colors\nconvert_colors_to_numbers <- function(colors) {\n  # Turn colors into numbers, but assign NA to background color\n  color_numbers <- as.numeric(factor(colors, levels = unique(colors[-which(colors == background)])))\n\n  # Change all NA values to the letter \"B\"\n  color_numbers <- ifelse(is.na(color_numbers), \"B\", color_numbers)\n\n  return(color_numbers)\n}\n\nfinal_df$color_numbers <- convert_colors_to_numbers(final_df$color)\n\n# Create the pbn plot\npaint_by_numbers <-\n  ggplot(final_df, aes(x = x, y = y, fill = color, label = color_numbers)) +\n  geom_tile(alpha = 0.5, color = \"black\") +  # Add tiles\n  geom_text(size = 2.6) +\n  scale_x_continuous(position = \"top\",\n                     expand = c(0,0),\n                     breaks =  1:nrow(final_df)) +\n  scale_y_reverse(expand = c(0,0),\n                     breaks =  1:nrow(final_df)) +\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  #theme_void() +  # Remove axis labels and background\n  coord_equal() +  # Use equal aspect ratio\n  labs(x = NULL, y = NULL) +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.text.x = element_text(angle = 90))\n```\n:::\n\n\n\n![](images/01-paint-by-numbers.png){fig-align=\"center\"}\n\nBAM! I think that looks great. I‚Äôd find that really helpful if I was planning a quilt or something. I do know, however, that this plot will not work past a certain `size` if I want the user to be able to download a PDF to US letter or A4 size. I think I should do some tests to see what the maximum printable size will be, but that's not a priority. I‚Äôm sure there is a way to allow them to print any size and just tape together multiple printed pages, but I don‚Äôt want to worry about that. If I can only go to 40 x 40 grids and I want a 100‚Äù by 100‚Äù quilt, I‚Äôll just do the math to see how many inches wide each of my squares needs to be. Quilters are math whizzes, I‚Äôm not worried about them.  \n\nWish I knew more about plotting, saving images, and printing. Oh, well, that's another project. As long as I set a size = 40 grid to print an 8‚Äù square grid, I know things will work for folks. I tried up to size = 60 and it worked. I can set these limits when I build the app by constraining the min and max of my sliders (or whatever I use) to a min of 13 and a max of 60.  \n\nNow, I am going to do something scary. I‚Äôm going to update `{ggplot2}`. Ok, nothing broke! SHEW.  \n\n![](images/02-final-with-paperwhite-bkgrnd.png){fig-align=\"center\"}\n\nI also just updated the color assignment script so that if the background is paper white, the colors includes black, but if the background is black, black is removed from the color list.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the colors\nbackground <- \"black\" #EDEFEE\"\n\nif (background == \"#EDEFEE\"){ # If background is paper white\n  colors <- c(#\"#EDEFEE\", # Paper\n    \"#1A8BB3\", # Teal - no longer teal, just bright blue\n    \"#0950AE\", # Dark blue\n    \"#4DACE5\", # Light blue\n    \"#126DDB\", # Blue\n    \"#E48DC4\", # Pink\n    \"#ABA9E8\", # Light purple\n    \"#872791\", # Purple\n    \"#6D1617\", # Dark red\n    \"#B81634\", # Red\n    \"#DF3B43\", # Red orange\n    \"#E35C47\", # Orange\n    \"#EB8749\", # Light orange\n    \"#F6E254\", # Yellow\n    \"#7B442D\", # Brown\n    \"#000000\", # Black\n    \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n    \"#7CBF7B\", # Green\n    \"#ADD2B8\") # Light green\n} else { # else (if black), remove black from colors\n  colors <- c(#\"#EDEFEE\", # Paper\n    \"#1A8BB3\", # Teal - no longer teal, just bright blue\n    \"#0950AE\", # Dark blue\n    \"#4DACE5\", # Light blue\n    \"#126DDB\", # Blue\n    \"#E48DC4\", # Pink\n    \"#ABA9E8\", # Light purple\n    \"#872791\", # Purple\n    \"#6D1617\", # Dark red\n    \"#B81634\", # Red\n    \"#DF3B43\", # Red orange\n    \"#E35C47\", # Orange\n    \"#EB8749\", # Light orange\n    \"#F6E254\", # Yellow\n    \"#7B442D\", # Brown\n    #\"#000000\", # Black\n    \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n    \"#7CBF7B\", # Green\n    \"#ADD2B8\") # Light green\n}\n```\n:::\n\n\n\n![](images/03-final-with-black-bkgrnd.png){fig-align=\"center\"}\n\nI will obviously need to make this more clear once it‚Äôs all inside the app, but as it will be an input with a default, none of the commenting out of stuff will really be needed.  \n\nNext small target: get the numbers that correspond to the hex colors to print with the palette plot, or at least in a stand alone table. Might need to dig into the hues package and modify something.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhues::swatch\nfunction (x) \n{\n    par(mai = c(0.2, max(strwidth(x, \"inch\") + 0.4, na.rm = TRUE), \n        0.2, 0.4))\n    barplot(rep(1, length(x)), col = rev(x), space = 0.1, axes = FALSE, \n        names.arg = rev(x), cex.names = 0.8, horiz = T, las = 1)\n    return(invisible(NULL))\n}\n```\n:::\n\n\n\n## March 8th, 2024  \n\nSHEW! What a ride the last week has been. My laptop kicked the bucket for good this time and I had to get a new one and set it up. I‚Äôm still not used to it. Switching back to a Mac after a decade of being on Windows has been disorienting, and I never coded on a Mac back when I used them daily.  \n\nMy next task is to get the colors that correspond to the numbers to print on the palette grid, so let‚Äôs do that. Then, I really need to organize my file and send them off to my generous friend Santiago for a code review! I kind of have no idea how to organize things in their pre-app state, so I‚Äôm going to have to take some notes to figure it out.  \n\nSo, as I looked at last time, here‚Äôs the swatch function in the hues package, which is thankfully VERY basic base R ü•≥ baseR4LYFE. Let me comment on what‚Äôs happening here because I need to google some of these functions and refresh myself on what they do.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhues::swatch\nfunction (x) # x is a vector of colors\n{\n\t\t# set plotting parameters\n    par(\n    \n    # mai specifies the margins in inches as (bottom, left, top, right)\n    mai = c(0.2, # bottom margin == .2\"\n\t\t\t\t    # left margin == the width in inches of the longest color name + .4\"\n\t\t\t\t    max(strwidth(x, \"inch\") + 0.4, na.rm = TRUE), \n\t\t        0.2, # top margin == .2\"\n\t\t        0.4))# right margin == .4\"\n        \n    # create a bar plot\n    barplot(\n\t    rep(1, length(x)), # create as many bars of height 1 as there are colors\n\t    col = rev(x), # color the bars using the vector of colors in reverse order\n\t    space = 0.1, # keep 10% (.1) of each bar's height as space between the bars\n\t    axes = FALSE, # Don't draw an axis line\n      names.arg = rev(x), # labels below each bar; colors vector in reverse order\n      cex.names = 0.8, # expansion factor for bar labels; shrink to 80% (.8)\n      horiz = T, # draw bars horizontally (first bar goes at the bottom)\n      las = 1) # specify the orientation of the bar labels (1 = horizontal)\n      \n    return(invisible(NULL)) # don't print the plot if it's just being assigned\n}\n```\n:::\n\n\n\nSo, now I know exactly what everything does and I know I can create a function that does this, plus adds the color number, by letting the function accept two arguments, the color column and the color number column, and then using a paste function to add the color number to the `names.arg` option. \n\nOne problem: the way I‚Äôve written the `convert_colors_to_numbers()` function, it doesn‚Äôt apply to the original vector of possible colors, it applies to the colors column of the entire data frame, which maybe isn‚Äôt ideal. That means I don‚Äôt have a vector of color numbers in the same order as their colors. If I rewrote that function to create a matching vector of color numbers, I‚Äôd have to rewrite the functions that assign colors to also assign color numbers as a list, and I don‚Äôt particularly want to do that, just for readability. \n\nWhat else could I do after-the-fact? I could go into the `final_df` data frame and find the unique colors and their color numbers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a df of just the unique colors and their numbers\ncolors_and_numbers <- unique(final_df[,c('color','color_numbers')])\n\n# Function to plot the palette with it's numbers, based on hues::swatch()\nplot_number_swatch <- function (x) # df containing two rows, color & color numbers\n{\n\t\t# create labels vector\n\t\tlabels <- paste0(x[[2]], \": \", x[[1]])\n\t\t\n\t\t# set plotting parameters\n    par(\n    \n    # mai specifies the margins in inches as (bottom, left, top, right)\n    mai = c(0.2, # bottom margin == .2\"\n\t\t\t\t    # left margin == the width in \" of the longest color+number combo name + .4\"\n\t\t\t\t    max(strwidth(labels, \"inch\") + 0.4, na.rm = TRUE), \n\t\t        0.2, # top margin == .2\"\n\t\t        0.4),# right margin == .4\"\n\t\tfamily = \"Courier\") # Just trying to ensure monospaced font\n        \n    # create a bar plot\n    barplot(\n\t    rep(1, nrow(x)), # create as many bars (of height 1) as there are colors\n\t    col = rev(x[[1]]), # color the bars using the vector of colors in reverse order\n\t    space = 0.1, # keep 10% (.1) of each bar's height as space between the bars\n\t    axes = FALSE, # Don't draw an axis line\n      names.arg = rev(labels), # labels below each bar; colors vector in reverse order\n      cex.names = 0.8, # expansion factor for bar labels; shrink to 80% (.8)\n      horiz = T, # draw bars horizontally (first bar goes at the bottom)\n      las = 1) # specify the orientation of the bar labels (1 = horizontal)\n      \n    return(invisible(NULL)) # don't print the plot if it's just being assigned\n}\n\nplot_number_swatch(colors_and_numbers)\n```\n:::\n\n\n\n![](images/04-bar-swatches-with-numbers.png){fig-align=\"center\"}\n\nOk, good enough for me! I'm envisioning this as a second iteration of the app. I need to get a functioning app first, one that just creates the pieces using the pre-determined color palette. The \"extra\" iterations can be adding things like custom colors, the \"paint-by-number\" plot, and the palette swatch thing.  \n\n[**Note from Future Libby: Well, this is it. This is the last \"old\" bit of documentation from last year. I had to step away from this project after the spring of 2024, and I've only now been able to get back to it in June of 2025. It's time!**]\n\nI can't believe I'm saying this, but I guess I'll add an eighth part to this series to show you my notes on the app code üòÖ but here's [the app in its current form](https://libbyheeren-ellsworth.share.connect.posit.cloud/) if you'd like to play with it!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}