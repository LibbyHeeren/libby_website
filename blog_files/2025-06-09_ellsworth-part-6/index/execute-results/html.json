{
  "hash": "fe03c59afcf56515d6b6a4717b302918",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Ellsworth Project: Part 6\"\ndescription: \"Documenting the creation of <a href='https://libbyheeren-ellsworth.share.connect.posit.cloud/'>The Ellsworth App</a>, in which I figure out how to assign colors to the matrix so they don't clump.\"\ndate: \"2025-06-09\"\nimage: images/00-cover-image.png\nimage-alt: \"A small hand-drawn 4 by 4 matrix grid with some squares colored yellow, pink, green, and blue. Three yellow squares are touching each other, and those three are circled in pink with a note that says 'technically, this could happen, but the outer edge of the final matrix will be changed to the background color anyway.'\"\ncategories:\n  - R\n  - Shiny\n# bibliography: references.bib\n# number-sections: true\nnumber-depth: 2\nexecute: \n  eval: false # no code chunks will evaluate, just the code will show up\ndraft: false # true prevents this from going in the listing\nformat:\n  html:\n    fig-align: center\n---\n\n\n\n------------------------------------------------------------------------\n\n## February 27th, 2024\n\nWow, I barely slept last night. And all I want to do now is the exact thing I tried to talk myself out of yesterday: regulate the groupings of colors so that no more than two can be touching. I gotta at least play around with it, right?  \n\nMy current process for generating and assigning colors is this:  \n\n- Define size and colors and maybe background  \n- Generate a random vector of colors, one for each cell of a size x size grid  \n- Create a data frame of coordinates and add the color vector to it  \n\nThe change Iâ€™m proposing, in raw idea form is this:  \n\n- Define size and colors and background  \n- Create an empty size x size matrix  \n- Write a loop that goes through the matrix row by row or column by column and assigns a random color to each cell (using the same method `sample(x = colors, size = size * size, replace = TRUE)`)  \n    - See handwritten notes below  \n    - But, before assigning a color at all, check to see if the adjacent filled cells are the same color. If they are, remove that color from the sample list of colors:  \n        \n        `sample(x =` \n        `colors[-which(colors == same_color)], size = ~~size * size~~ 1, replace = TRUE)`\n        \n- Create a data frame of coordinates, convert the color matrix to a vector, and add the vector of colors to the data frame  \n\nThe resulting data frame of colors, when plotted, should show no more than two squares of the same color grouped together, except for the possibility of some clustering on the top left edge, which wonâ€™t be seen anyway as the outer circuit will always be changed to the background color. This will (I think) add a constraint around the number of colors, because I think youâ€™d need at least 5 colors in order to not have clustering. I guess I can test it.  \n\n![](images/01-nested-ifs.jpeg){fig-align=\"center\"}\n\nMuahaha, look at that complex nested ifelse monstrosity! Let me see if it works, and then I can think about simplifying it.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define all the stuff\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Choose background color, #EDEFEE is paper, #000000 is black\nbackground <- \"#EDEFEE\"\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n  \"#1A8BB3\", # Teal - no longer teal, just bright blue\n  \"#0950AE\", # Dark blue\n  \"#4DACE5\", # Light blue\n  \"#126DDB\", # Blue\n  \"#E48DC4\", # Pink\n  \"#ABA9E8\", # Light purple\n  \"#872791\", # Purple\n  \"#6D1617\", # Dark red\n  \"#B81634\", # Red\n  \"#DF3B43\", # Red orange\n  \"#E35C47\", # Orange\n  \"#EB8749\", # Light orange\n  \"#F6E254\", # Yellow\n  \"#7B442D\", # Brown\n  \"#000000\", # Black\n  \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n  \"#7CBF7B\", # Green\n  \"#ADD2B8\") # Light green\n\n##### Create a replacement get_color_vector function\nget_color_vector <- function(size, colors){\n  \n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n  \n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n    \n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n      \n      # If you're in the first cell, assign a random color\n      if (i == 1 && j == 1){\n        color_matrix[i,j] <- sample(x = colors, \n                                    size = 1, \n                                    replace = TRUE)\n      } else if (i == 1 && j != 1){ # if rest of first row\n        \n        # Check the color of the cell to the left\n        left_color <- color_matrix[i, j-1]\n        # Assign anything but that color to this cell\n        color_matrix[i,j] <- sample(x = colors[-which(colors == left_color)], \n                                    size = 1, \n                                    replace = TRUE)\n      \n      } else if (i != 1 && j == 1){ # if in 1st col of rows 2:end\n        \n        # Check the color of the cell above\n        up_color <- color_matrix[i-1, j]\n        # Assign anything but that color to this cell\n        color_matrix[i,j] <- sample(x = colors[-which(colors == up_color)], \n                                    size = 1, \n                                    replace = TRUE)\n      } else {\n        \n        # Check both left and up colors\n        left_color <- color_matrix[i, j-1]\n        up_color <- color_matrix[i-1, j]\n        \n        # Check if they're the same color, if so, assign other color\n        if (left_color == up_color){\n          color_matrix[i,j] <- sample(x = colors[-which(colors == up_color)], \n                                      size = 1, \n                                      replace = TRUE)\n        } else {\n          \n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors, \n                                      size = 1, \n                                      replace = TRUE)\n        }\n      }\n    }\n  }\n  \n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n}\n\n# Get new color vector and bind it to a data frame of coordinates\n\ncolor_vector <- get_color_vector(size, colors)\n\ndf <- expand.grid(x = 1:size, y = 1:size)\n\ndf$color <- color_vector\n\n# Print to see if it worked\n\nggplot(df, aes(x = x, y = y, fill = color)) +\n  geom_tile() +  # Add tiles\n\tscale_y_reverse() +\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  theme_void() +  # Remove axis labels and background\n  coord_equal()\n```\n:::\n\n\n\n![](images/02-after-many-errors.png){fig-align=\"center\"}\n\nHere are the errors I went through before the above worked:  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$color <- color_vector\n# Error in rep(value, length.out = nrows) : \n#   attempt to replicate an object of type 'closure'\n# ^ oops, I forgot the parentheses and args in color_vector <- get_color_vector above that\n\ncolor_vector <- get_color_vector(size, colors)\n# Error in if (c(i, j) == c(1, 1)) { : the condition has length > 1\n# ^ oops, I knew I should have just used (i == 1 && j == 1) but I got hasty\n\ncolor_vector <- get_color_vector(size, colors)\n# Error in color_matrix[i, j] <- sample(x = colors, size = size * size,  : \n#   number of items to replace is not a multiple of replacement length\n# ^ oops, I had size = 1600 instead of size = 1 in all my sample() calls\n```\n:::\n\n\n\nAlas, Iâ€™ve got some issues with the plot because there are areas in which more than two squares of the same color have been allowed to touch! When itâ€™s only checking the square to the left and the square above to compare them, it leaves the possibility for a horizontal or vertical line of the same color. How can I fix that? If I always check for the up color and left color, and always avoid them, then Iâ€™ll likely never allow two of the same color next to each other. I kinda LIKE having pairs here and there, though.\n\nWhat if, starting in the third row down and the third column over, I check if up == left, but also if left 1 == left 2 or up 1 == up 2. That is, check the square above to see if it matches the square above it, and check the square to the left and the square to the left of that. If any of those three conditions is TRUE, Iâ€™ll exclude the offending color from my possible sample. Somehow. See, this is why I need at least 5 colors.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Second try to create a replacement get_color_vector function\nget_color_vector <- function(size, colors){\n\n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n\n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n\n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n\n      # If you're in the first cell, assign a random color\n      if (i == 1 && j == 1){\n        color_matrix[i,j] <- sample(x = colors,\n                                    size = 1,\n                                    replace = TRUE)\n        (paste0(\"cell \", i, \", \", j, \" filled\"))\n      } else if (i == 1 && j > 1){ # if rest of first row\n\n        # Check the color of the cell to the left\n        left_color <- color_matrix[i, j-1]\n        # Assign anything but that color to this cell\n        color_matrix[i,j] <- sample(x = colors[-which(colors == left_color)],\n                                    size = 1,\n                                    replace = TRUE)\n        paste0(\"cell \", i, \", \", j, \" filled\")\n\n      } else if (i == 2 && j == 1){ # if in 1st col of row 2\n\n        # Check the color of the cell above\n        up_color <- color_matrix[i-1, j]\n        # Assign anything but that color to this cell\n        color_matrix[i,j] <- sample(x = colors[-which(colors == up_color)],\n                                    size = 1,\n                                    replace = TRUE)\n        paste0(\"cell \", i, \", \", j, \" filled\")\n      } else if (i == 2 && j > 2){ # if in second row, cols 3:end\n\n        # Check both 2 left and 1 up colors\n        left_color1 <- color_matrix[i, j-1]\n        left_color2 <- color_matrix[i, j-2]\n        up_color <- color_matrix[i-1, j]\n\n        # Check if they're the same color, if so, assign other color\n        if (left_color == up_color || left_color1 == left_color2){\n          color_matrix[i,j] <- sample(x = colors[-which(colors %in% c(up_color, left_color1))],\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        } else {\n\n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        }\n      } else if (i > 2 && j == 1){ # if in first col of rows 3 and down\n\n        # Check colors of up1 and up2\n        up_color1 <- color_matrix[i-1, j]\n        up_color2 <- color_matrix[i-2, j]\n\n        # Check if they're the same color, if so, assign other color\n        if (up_color1 == up_color2){\n          color_matrix[i,j] <- sample(x = colors[-which(colors == up_color1)],\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        } else {\n\n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        }\n      } else if (i > 2 && j > 2){ # if in row 3 and down, col 3 and over\n\n        # Check for all three conditions\n        left_color1 <- color_matrix[i, j-1]\n        left_color2 <- color_matrix[i, j-2]\n        up_color1 <- color_matrix[i-1, j]\n        up_color2 <- color_matrix[i-2, j]\n\n        # If any matches, assign other color\n        if (left_color1 == left_color2 || left_color1 == up_color1 || up_color1 == up_color2){\n\n          color_matrix[i,j] <- sample(x = (colors[-which(colors %in% c(up_color1, left_color1))]),\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        } else {\n\n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n\n        }\n      }\n    }\n  }\n\n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n}\n```\n:::\n\n\n\nWhat is this monstrosity??? And does it even work?  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get new color vector and bind it to a data frame of coordinates\n\ncolor_vector <- get_color_vector(size, colors)\n\ndf <- expand.grid(x = 1:size, y = 1:size)\n\ndf$color <- color_vector\n\n# Print to see if it worked\n\nggplot(df, aes(x = x, y = y, fill = color)) +\n  geom_tile() +  # Add tiles\n\tscale_y_reverse() +\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  theme_void() +  # Remove axis labels and background\n  coord_equal()\n```\n:::\n\n\n\nErrors I had to navigate:  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolor_vector <- get_color_vector(size, colors)\n# Error in colors == up_color || colors == left_color1 : \n#   'length = 18' in coercion to 'logical(1)'\n# ^ oops, rewrote using %in%\n\ncolor_vector <- get_color_vector(size, colors)\n# Error in sample.int(length(x), size, replace, prob) : \n#   invalid first argument\n# ^ oops, I didn't give my if statement containing the sample() call an else\n\n# <error/rlang_error>\n# Error in `geom_tile()`:\n# ! Problem while converting geom to grob.\n# â„¹ Error occurred in the 1st layer.\n# Caused by error:\n# ! Unknown colour name: \n# ^ oops, my if else statements were not inclusive of every cell and I ended up with \n# 40 empty cells, which is either an entire row or an entire column\n\n# Here's how I figured out which ones where missing:\nunique(color_vector)\n#  [1] \"#B81634\" \"#ABA9E8\" \"#1A8BB3\"\n#  [4] \"#000000\" \"#6D1617\" \"#1A6E7E\"\n#  [7] \"#7B442D\" \"#4DACE5\" \"#EB8749\"\n# [10] \"#872791\" \"#ADD2B8\" \"#E48DC4\"\n# [13] \"#E35C47\" \"#DF3B43\" \"#F6E254\"\n# [16] \"#126DDB\" \"#0950AE\" \"#7CBF7B\"\n# [19] \"\"  \n\ncolor_vector <- if_else(color_vector == \"\", true = \"white\", false = color_vector)\n\ncolor_vector <- if_else(color_vector == \"\", true = \"white\", false = color_vector)\n\nggplot(df, aes(x = x, y = y, fill = color)) +\n     geom_tile() +  # Add tiles\n     scale_y_reverse() +\n     scale_fill_identity() +  # Use the colors stored as strings in the color column\n     theme_void() +  # Remove axis labels and background\n     coord_equal()\n```\n:::\n\n\n\n![](images/03-plot-row-missing-top.png){fig-align=\"center\"}\n\nBingo. In row 2, columns 2:end are missing. I went back and fixed one of the loops to say row 2, col 1 or 2.  \n\nAnd, finally, after navigating alllll the errors (there were more than I notated, but I mentioned the main ones once even if they took me several tries to fix), I got this:  \n\n![](images/04-a-few-tetris-shapes.png){fig-align=\"center\"}\n\nI see a few instances of an L-shaped piece, revealing another case: I need to also check left_color1 against up_left_color ðŸ˜‚ which would be one up and one left of the current square. Goodness! Ok, Iâ€™m gonna try. Why not, Iâ€™m having a ton of fun!  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Second try to create a replacement get_color_vector function\nget_color_vector <- function(size, colors){\n\n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n\n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n\n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n\n      # If you're in the first cell, assign a random color\n      if (i == 1 && j == 1){\n        color_matrix[i,j] <- sample(x = colors,\n                                    size = 1,\n                                    replace = TRUE)\n        (paste0(\"cell \", i, \", \", j, \" filled\"))\n      } else if (i == 1 && j > 1){ # if rest of first row\n\n        # Check the color of the cell to the left\n        left_color <- color_matrix[i, j-1]\n        # Assign anything but that color to this cell\n        color_matrix[i,j] <- sample(x = colors[-which(colors == left_color)],\n                                    size = 1,\n                                    replace = TRUE)\n        paste0(\"cell \", i, \", \", j, \" filled\")\n\n      } else if (i == 2 && j == 1 || j == 2){ # if in 1st or 2nd col of row 2\n\n        # Check the color of the cell above\n        up_color <- color_matrix[i-1, j]\n        # Assign anything but that color to this cell\n        color_matrix[i,j] <- sample(x = colors[-which(colors == up_color)],\n                                    size = 1,\n                                    replace = TRUE)\n        paste0(\"cell \", i, \", \", j, \" filled\")\n      } else if (i == 2 && j > 2){ # if in second row, cols 3:end\n\n        # Check both 2 left and 1 up colors, plus up_left\n        left_color1 <- color_matrix[i, j-1]\n        left_color2 <- color_matrix[i, j-2]\n        up_color <- color_matrix[i-1, j]\n        up_left_color <- color_matrix[i-1, j-1]\n\n        # Check if they're the same color, if so, assign other color\n        if (left_color1 == up_color || left_color1 == left_color2 || left_color1 == up_left_color){\n          color_matrix[i,j] <- sample(x = colors[-which(colors %in% c(up_color, left_color1))],\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        } else {\n\n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        }\n      } else if (i > 2 && j == 1){ # if in first col of rows 3 and down\n\n        # Check colors of up1 and up2\n        up_color1 <- color_matrix[i-1, j]\n        up_color2 <- color_matrix[i-2, j]\n\n        # Check if they're the same color, if so, assign other color\n        if (up_color1 == up_color2){\n          color_matrix[i,j] <- sample(x = colors[-which(colors == up_color1)],\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        } else {\n\n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        }\n      } else if (i > 2 && j > 2){ # if in row 3 and down, col 3 and over\n\n        # Check for all three conditions plus up_left\n        left_color1 <- color_matrix[i, j-1]\n        left_color2 <- color_matrix[i, j-2]\n        up_color1 <- color_matrix[i-1, j]\n        up_color2 <- color_matrix[i-2, j]\n        up_left_color <- color_matrix[i-1, j-1]\n\n        # If any matches, assign other color\n        if (left_color1 == left_color2 || left_color1 == up_color1 || up_color1 == up_color2 || up_left_color == left_color1){\n\n          color_matrix[i,j] <- sample(x = (colors[-which(colors %in% c(up_color1, left_color1))]),\n                                      size = 1,\n                                      replace = TRUE)\n          paste0(\"cell \", i, \", \", j, \" filled\")\n        } else {\n\n          # If colors aren't the same, assign a random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n\n        }\n      }\n    }\n  }\n\n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n}\n\n# Get new color vector and bind it to a data frame of coordinates\n\ncolor_vector <- get_color_vector(size, colors)\n\ndf <- expand.grid(x = 1:size, y = 1:size)\n\ndf$color <- color_vector\n\n# Print to see if it worked\n\nggplot(df, aes(x = x, y = y, fill = color)) +\n  geom_tile() +  # Add tiles\n\tscale_y_reverse() +\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  theme_void() +  # Remove axis labels and background\n  coord_equal()\n```\n:::\n\n\n\n![](images/05-did-it-work.png){fig-align=\"center\"}\n\nOMG. Did that work?! I think so! Time for dinner. \n\n---\n\nCan the food I just ate fuel me to simplify my ridiculously over-sized function? ðŸ˜‚ Right now, Iâ€™m writing all these conditions and nested if else statements. Can I go element-by-element through the matrix and take these steps?  \n\n- Check if the five spaces to the left and above the cell exist  \n    - M[i-1, j], M[i-2, j], M[i-1, j-1], M[i, j-1], M[i, j-2]  \n    - `left_color1 <- ifelse((j-1) > 0, color_matrix[i, j-1], \"\")`  \n    `left_color2 <- ifelse((j-2) > 0, color_matrix[i, j-2], \"\")`  \n    `up_color1 <- ifelse((i-1) > 0, color_matrix[i-1, j], \"\")`  \n    `up_color2 <- ifelse((i-2) > 0, color_matrix[i-2, j], \"\")`  \n    `up_left_color <- ifelse((j-1) > 0 && (i-1) > 1, color_matrix[i-1, j-1], \"\")`  \n    `up_right_color <- ifelse((i-1) > 0 && (j+1) < (ncol(color_matrix)+1), color_matrix[i-1, j+1], \"\")`  \n    - Use â€â€ or something other than NA? Anything matched with an NA would return NA, not true or false. What would that do to an if statement? It would throw an error. If I use â€œâ€ then the comparison would work.  \n- For the ones that exist, capture their colors  \n- Check to see if any relevant color pairings match, but only for all but cell [1, 1]  \n    - left_color1 == left_color2 || left_color1 == up_color1 || up_color1 == up_color2 || up_left_color == left_color1  \n        - Need to add up1 to up_left and up1 to up right  \n        - Comparisons that end up being â€œâ€ == â€œâ€ because cell is in row 1 or col 1 - what will happen? Iâ€™ll ask it to assign a color sampled from the colors vector that doesnâ€™t include the color â€œâ€, which will mean it can assign any color. Right? Test.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Try with actual colors that exist in the 18 length vector called colors\ncolors[-which(colors %in% c(\"#1A8BB3\", \"#0950AE\"))]\n#  [1] \"#4DACE5\" \"#126DDB\"\n#  [3] \"#E48DC4\" \"#ABA9E8\"\n#  [5] \"#872791\" \"#6D1617\"\n#  [7] \"#B81634\" \"#DF3B43\"\n#  [9] \"#E35C47\" \"#EB8749\"\n# [11] \"#F6E254\" \"#7B442D\"\n# [13] \"#000000\" \"#1A6E7E\"\n# [15] \"#7CBF7B\" \"#ADD2B8\"\n\n# Now, with blanks\ncolors[-which(colors %in% c(\"\", \"\"))]\n# character(0)\n\n# That's not good.\n```\n:::\n\n\n\nWhat if I assigned all the colors, including the blanks, to a vector, on which I called `unique()`, and then passed that to `which()`?  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurrounding <- unique(c(\"\", \"#1A8BB3\", \"#0950AE\", \"#1A8BB3\", \"\"))\n\ncolors[-which(colors %in% surrounding)]\n#  [1] \"#4DACE5\" \"#126DDB\"\n#  [3] \"#E48DC4\" \"#ABA9E8\"\n#  [5] \"#872791\" \"#6D1617\"\n#  [7] \"#B81634\" \"#DF3B43\"\n#  [9] \"#E35C47\" \"#EB8749\"\n# [11] \"#F6E254\" \"#7B442D\"\n# [13] \"#000000\" \"#1A6E7E\"\n# [15] \"#7CBF7B\" \"#ADD2B8\"\n```\n:::\n\n\n\nThat works, but what if theyâ€™re *all* blank?  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurrounding <- unique(c(\"\", \"\", \"\", \"\", \"\"))\n\ncolors[-which(colors %in% surrounding)]\n# character(0)\n```\n:::\n\n\n\nSo, as long as thereâ€™s one color in there, it will be ok, and there will always be at least one color in the list of the five surrounding cells as long as the cell isnâ€™t the top left one, M[1, 1].  \n\nIf there are any matches, I donâ€™t want to discard all the colors if I donâ€™t have to. Can I use `case_when` or something to create a vector of only colors that matched?  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatching <- vector(mode = \"character\", length = 6)\n\nmatching[1] <- ifelse(left_color1 == left_color2, left_color1, \"\")\nmatching[2] <- ifelse(left_color1 == up_color1, left_color1, \"\")\nmatching[3] <- ifelse(up_color1 == up_color2, up_color1, \"\")\nmatching[4] <- ifelse(up_left_color == left_color1, up_left_color, \"\")\nmatching[5] <- ifelse(up_left_color == up_color1, up_left_color, \"\")\nmatching[6] <- ifelse(up_right_color == up_color1, up_right_color, \"\")\n\n\nmatching <- unique(matching[which(matching != \"\")])\n```\n:::\n\n\n\nSo, if there are matches, Iâ€™ll avoid assigning the cell the matching colors, if there aren't matches, any color can be assigned.  \n\nOK! Let me try to write the full, consolidated/simplified function:  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Third try to create a replacement get_color_vector function\nget_color_vector <- function(size, colors){\n  \n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n  \n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n    \n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n      \n      # If you're in the first (top left) cell, assign a random color\n      if (i == 1 && j == 1){\n        \n        color_matrix[i,j] <- sample(x = colors,\n                                    size = 1,\n                                    replace = TRUE)\n      \n      # If you're in any other cell than the top left  \n      } else {\n        \n        # Get the colors of the five surrounding cells\n        left_color1 <- ifelse((j-1) > 0, color_matrix[i, j-1], \"\")\n        left_color2 <- ifelse((j-2) > 0, color_matrix[i, j-2], \"\")\n        up_color1 <- ifelse((i-1) > 0, color_matrix[i-1, j], \"\")\n        up_color2 <- ifelse((i-2) > 0, color_matrix[i-2, j], \"\")\n        up_left_color <- ifelse((j-1) > 0 && (i-1) > 1, color_matrix[i-1, j-1], \"\")\n        \n        # Put them in a vector called surrounding\n        surrounding <- c(left_color1, \n                         left_color2,\n                         up_color1,\n                         up_color2,\n                         up_left_color)\n        \n        # Check to see if any of the relavent cell colors match\n        matching <- vector(mode = \"character\", length = 5)\n        \n        matching[1] <- ifelse(left_color1 == left_color2, left_color1, \"\")\n        matching[2] <- ifelse(left_color1 == up_color1, left_color1, \"\")\n        matching[3] <- ifelse(up_color1 == up_color2, up_color1, \"\")\n        matching[4] <- ifelse(up_left_color == left_color1, up_left_color, \"\")\n        matching[5] <- ifelse(up_left_color == up_color1, up_left_color, \"\")\n        \n        matching <- unique(matching[which(matching != \"\")])\n        \n        # If there were no matches\n        if (length(matching) == 0){\n          \n          # Assign any random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          \n        } else { # If there WERE matches\n          \n          # Assign any other color than those in matches vector\n          color_matrix[i,j] <- sample(x = colors[-which(colors %in% matching)],\n                                      size = 1,\n                                      replace = TRUE)\n        }\n      }\n    }\n  }  \n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n} # 66 lines vs 108 for the previous version. Nice! Well, if it works.\n```\n:::\n\n\n\nTime to see if it works and troubleshoot if not.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define all the stuff\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n# Choose background color, #EDEFEE is paper, #000000 is black\nbackground <- \"#EDEFEE\"\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n  \"#1A8BB3\", # Teal - no longer teal, just bright blue\n  \"#0950AE\", # Dark blue\n  \"#4DACE5\", # Light blue\n  \"#126DDB\", # Blue\n  \"#E48DC4\", # Pink\n  \"#ABA9E8\", # Light purple\n  \"#872791\", # Purple\n  \"#6D1617\", # Dark red\n  \"#B81634\", # Red\n  \"#DF3B43\", # Red orange\n  \"#E35C47\", # Orange\n  \"#EB8749\", # Light orange\n  \"#F6E254\", # Yellow\n  \"#7B442D\", # Brown\n  \"#000000\", # Black\n  \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n  \"#7CBF7B\", # Green\n  \"#ADD2B8\") # Light green\n\n# Third try to create a replacement get_color_vector function\nget_color_vector <- function(size, colors){\n  \n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n  \n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n    \n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n      \n      # If you're in the first (top left) cell, assign a random color\n      if (i == 1 && j == 1){\n        \n        color_matrix[i,j] <- sample(x = colors,\n                                    size = 1,\n                                    replace = TRUE)\n      \n      # If you're in any other cell than the top left  \n      } else {\n        \n        # Get the colors of the five surrounding cells\n        left_color1 <- ifelse((j-1) > 0, color_matrix[i, j-1], \"\")\n        left_color2 <- ifelse((j-2) > 0, color_matrix[i, j-2], \"\")\n        up_color1 <- ifelse((i-1) > 0, color_matrix[i-1, j], \"\")\n        up_color2 <- ifelse((i-2) > 0, color_matrix[i-2, j], \"\")\n        up_left_color <- ifelse((j-1) > 0 && (i-1) > 1, color_matrix[i-1, j-1], \"\")\n        up_right_color <- ifelse((i-1) > 0 && (j+1) < (ncol(color_matrix)+1), \n                                 color_matrix[i-1, j+1], \"\")\n        \n        # Put them in a vector called surrounding\n        surrounding <- c(left_color1, \n                         left_color2,\n                         up_color1,\n                         up_color2,\n                         up_left_color,\n                         up_right_color)\n        \n        # Check to see if any of the relavent cell colors match\n        matching <- vector(mode = \"character\", length = 6)\n        \n        matching[1] <- ifelse(left_color1 == left_color2, left_color1, \"\")\n        matching[2] <- ifelse(left_color1 == up_color1, left_color1, \"\")\n        matching[3] <- ifelse(up_color1 == up_color2, up_color1, \"\")\n        matching[4] <- ifelse(up_left_color == left_color1, up_left_color, \"\")\n        matching[5] <- ifelse(up_left_color == up_color1, up_left_color, \"\")\n        matching[6] <- ifelse(up_right_color == up_color1, up_right_color, \"\")\n        \n        matching <- unique(matching[which(matching != \"\")])\n        \n        # If there were no matches\n        if (length(matching) == 0){\n          \n          # Assign any random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          \n        } else { # If there WERE matches\n          \n          # Assign any other color than those in matches vector\n          color_matrix[i,j] <- sample(x = colors[-which(colors %in% matching)],\n                                      size = 1,\n                                      replace = TRUE)\n        }\n      }\n    }\n  }  \n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n}\n\n# Get new color vector and bind it to a data frame of coordinates\n\ncolor_vector <- get_color_vector(size, colors)\n\ndf <- expand.grid(x = 1:size, y = 1:size)\n\ndf$color <- color_vector\n\n# Print to see if it worked\n\nggplot(df, aes(x = x, y = y, fill = color)) +\n  geom_tile() +  # Add tiles\n\tscale_y_reverse() +\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  theme_void() +  # Remove axis labels and background\n  coord_equal()\n```\n:::\n\n\n\n![](images/06-after-much-tinkering.png){fig-align=\"center\"}\n\nWoo hoo! Worked as intended!! So pleased with that. I did stop and change one thing on the fly, which was adding the sixth comparison: comparing up_right with up_1. The only thing I donâ€™t love now is the number of paired pairs! The plot in particular has many.  \n\nIf up1 and up_left match, it would nice if we removed left1 from the options.   \nIf left1 and up left match, it would be nice if we removed up1 from the options.  \n\nI think I can just add these to the vector called matching. Iâ€™ll make it 2 longer in length and create two more checks for those values.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Another get_color_vector iteration, adding the 7th and 8th match criteria\nget_color_vector <- function(size, colors){\n  \n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n  \n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n    \n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n      \n      # If you're in the first (top left) cell, assign a random color\n      if (i == 1 && j == 1){\n        \n        color_matrix[i,j] <- sample(x = colors,\n                                    size = 1,\n                                    replace = TRUE)\n      \n      # If you're in any other cell than the top left  \n      } else {\n        \n        # Get the colors of the five surrounding cells\n        left_color1 <- ifelse((j-1) > 0, color_matrix[i, j-1], \"\")\n        left_color2 <- ifelse((j-2) > 0, color_matrix[i, j-2], \"\")\n        up_color1 <- ifelse((i-1) > 0, color_matrix[i-1, j], \"\")\n        up_color2 <- ifelse((i-2) > 0, color_matrix[i-2, j], \"\")\n        up_left_color <- ifelse((j-1) > 0 && (i-1) > 1, color_matrix[i-1, j-1], \"\")\n        up_right_color <- ifelse((i-1) > 0 && (j+1) < (ncol(color_matrix)+1), \n                                 color_matrix[i-1, j+1], \"\")\n        \n        # Put them in a vector called surrounding\n        surrounding <- c(left_color1, \n                         left_color2,\n                         up_color1,\n                         up_color2,\n                         up_left_color,\n                         up_right_color)\n        \n        # Check to see if any of the relavent cell colors match\n        matching <- vector(mode = \"character\", length = 8)\n        \n        matching[1] <- ifelse(left_color1 == left_color2, left_color1, \"\")\n        matching[2] <- ifelse(left_color1 == up_color1, left_color1, \"\")\n        matching[3] <- ifelse(up_color1 == up_color2, up_color1, \"\")\n        matching[4] <- ifelse(up_left_color == left_color1, up_left_color, \"\")\n        matching[5] <- ifelse(up_left_color == up_color1, up_left_color, \"\")\n        matching[6] <- ifelse(up_right_color == up_color1, up_right_color, \"\")\n        matching[7] <- ifelse(up_left_color == left_color1, up_color1, \"\")\n        matching[8] <- ifelse(up_left_color == up_color1, left_color1, \"\")\n        \n        \n        matching <- unique(matching[which(matching != \"\")])\n        \n        # If there were no matches\n        if (length(matching) == 0){\n          \n          # Assign any random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          \n        } else { # If there WERE matches\n          \n          # Assign any other color than those in matches vector\n          color_matrix[i,j] <- sample(x = colors[-which(colors %in% matching)],\n                                      size = 1,\n                                      replace = TRUE)\n        }\n      }\n    }\n  }  \n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n}\n```\n:::\n\n\n\n![](images/07-finally-only-two-touching.png){fig-align=\"center\"}  \n\nThere we go! Finally! This looks so great!! Now, Iâ€™d like to test some constraints:  \n\n- size - whatâ€™s the smallest viable value for size before the outer circuit and inner circuits donâ€™t provide the appropriate probabilities? From previous mistakes, I think it may be somewhere in the range of 12 to 16.  \n    - Itâ€™s 13!  \n- number of colors - whatâ€™s the smallest viable number of unique colors that can be used before something fails? My intuition tells me 5 or 6, because of my color pair conditionals.  \n    - Everything above 1 color passes! A 2 color grid is just a checker board due to the restrictions.   \n\nTime for bed very soon. Todayâ€™s progress was great, but tomorrow I need to wrangle my functions and make sure I know what the final versions of each function are. Before I go, Iâ€™m going to list out what I think they are.  \n\nPackages needed:  `ggplot2` and `pracma`  \n\n`get_prob_vector()`  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prob_vector <- function(circuits){\n\n  first10perc <- seq(0, 0.02857143, length.out = round(circuits*.10)+1) # 3\n\n  last90perc_length <- circuits - length(first10perc)\n\n  last10perc_length <- round(last90perc_length * (1/9)) # 2\n\n  middle80perc_length <- last90perc_length - last10perc_length # 15\n\n  middle80perc <- seq(0.02857143, 1, length.out = middle80perc_length+2)[-c(1, middle80perc_length+2)]\n\n  last10perc <- rep(1, last10perc_length)\n\n  prob_vector <- c(first10perc, middle80perc, last10perc)\n\n  return(prob_vector)\n}\n```\n:::\n\n\n\n`get_prob_matrix()`  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prob_matrix <- function(size, prob_vector){\n\n  # Calculate quad size same way as circuits\n  quad_size <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\n\n  # Create empty matrix for the quad\n  M <- matrix(0, nrow = quad_size, ncol = quad_size)\n\n  # For loop to assign prob_vector to correct cells in quadrant\n  for (i in 1:quad_size){\n\n    M[i, i:quad_size] <- prob_vector[i]\n    M[i:quad_size, i] <- prob_vector[i]\n  }\n\n  # if size is even,\n  if(size %% 2 == 0){\n    # mirror horizontally and column bind\n    M_right <- pracma::fliplr(M)\n    M <- cbind(M, M_right)\n\n    # then mirror vertically and row bind\n    M_down <- pracma::flipud(M)\n    M <- rbind(M, M_down)\n\n  }else{ # if size is odd\n    # mirror all but last col horizontally and col bind\n    M_right <- pracma::fliplr(M[ , 1:(quad_size-1)])\n    M <- cbind(M, M_right)\n\n    # then mirror all but last row vertically and row bind\n    M_down <- pracma::flipud(M[1:(quad_size-1), ])\n    M <- rbind(M, M_down)\n\n  }\n\n  return(M)\n}\n```\n:::\n\n\n\n`get_color_vector_blobs_ok()` (formerly `generate_color_vector`)  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_color_vector_blobs_ok <- function(size, colors) {\n\n  # Create a size^2 vector filled with a random sample of colors from a color list\n  color_vector <- sample(x = colors,\n                         size = size * size,   # \"size\" is the # of squares on each side\n                         replace = TRUE)\n\n  return(color_vector)\n}\n```\n:::\n\n\n\n`get_color_vector()` (no more than two of same color touching)  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_color_vector <- function(size, colors){\n  \n  # Define an empty size x size matrix\n  color_matrix <- matrix(\"\", nrow = size, ncol = size)\n  \n  # For loop to go row by row\n  for (i in 1:nrow(color_matrix)){\n    \n    # For loop to go column by column\n    for (j in 1:ncol(color_matrix)){\n      \n      # If you're in the first (top left) cell, assign a random color\n      if (i == 1 && j == 1){\n        \n        color_matrix[i,j] <- sample(x = colors,\n                                    size = 1,\n                                    replace = TRUE)\n      \n      # If you're in any other cell than the top left  \n      } else {\n        \n        # Get the colors of the five surrounding cells\n        left_color1 <- ifelse((j-1) > 0, color_matrix[i, j-1], \"\")\n        left_color2 <- ifelse((j-2) > 0, color_matrix[i, j-2], \"\")\n        up_color1 <- ifelse((i-1) > 0, color_matrix[i-1, j], \"\")\n        up_color2 <- ifelse((i-2) > 0, color_matrix[i-2, j], \"\")\n        up_left_color <- ifelse((j-1) > 0 && (i-1) > 1, color_matrix[i-1, j-1], \"\")\n        up_right_color <- ifelse((i-1) > 0 && (j+1) < (ncol(color_matrix)+1), \n                                 color_matrix[i-1, j+1], \"\")\n        \n        # Put them in a vector called surrounding\n        surrounding <- c(left_color1, \n                         left_color2,\n                         up_color1,\n                         up_color2,\n                         up_left_color,\n                         up_right_color)\n        \n        # Check to see if any of the relavent cell colors match\n        matching <- vector(mode = \"character\", length = 8)\n        \n        matching[1] <- ifelse(left_color1 == left_color2, left_color1, \"\")\n        matching[2] <- ifelse(left_color1 == up_color1, left_color1, \"\")\n        matching[3] <- ifelse(up_color1 == up_color2, up_color1, \"\")\n        matching[4] <- ifelse(up_left_color == left_color1, up_left_color, \"\")\n        matching[5] <- ifelse(up_left_color == up_color1, up_left_color, \"\")\n        matching[6] <- ifelse(up_right_color == up_color1, up_right_color, \"\")\n        matching[7] <- ifelse(up_left_color == left_color1, up_color1, \"\")\n        matching[8] <- ifelse(up_left_color == up_color1, left_color1, \"\")\n        \n        \n        matching <- unique(matching[which(matching != \"\")])\n        \n        # If there were no matches\n        if (length(matching) == 0){\n          \n          # Assign any random color\n          color_matrix[i,j] <- sample(x = colors,\n                                      size = 1,\n                                      replace = TRUE)\n          \n        } else { # If there WERE matches\n          \n          # Assign any other color than those in matches vector\n          color_matrix[i,j] <- sample(x = colors[-which(colors %in% matching)],\n                                      size = 1,\n                                      replace = TRUE)\n        }\n      }\n    }\n  }  \n  # return the color matrix as a vector\n  return(as.vector(color_matrix))\n}\n```\n:::\n\n\n\nPlotting full color grid with no gaps, VI style (is it VI? check.)  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = x, y = y, fill = color)) +\n  geom_tile() +  # Add tiles\n\tscale_y_reverse() +\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  theme_void() +  # Remove axis labels and background\n  coord_equal()\n```\n:::\n\n\n\n`get_kelly_III_vector()` (replaces colored tiles with white ones based on probabilities in `df$probs`)  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_kelly_III_vector <- function(df, background){\n  \n  # Write a loop that iterates over each row in df\n  for (i in 1:nrow(df)){\n    \n    if (df$probs[i] == 0){\n      df$color[i] <- background\n    } else if (df$probs[i] == 1){\n      df$color[i] <- df$color[i]\n    } else {\n      \n      # If the random is greater than probs, assign background, if not, do nothing\n      # grab a random number between 0 and 1\n      random <- runif(n = 1)\n      \n      if (random > df$probs[i]){\n        df$color[i] <- background\n      }\n    }\n  }\n  \n  return(df)\n  \n}\n```\n:::\n\n\n\nPrinting the Kelly III plot:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the size of the desired grid and calculate number of circuits\nsize <- 40\ncircuits <- ifelse(size %% 2 == 0, size/2, (size+1)/2)\nbackground <- \"#EDEFEE\"\n\n# Define the colors\ncolors <- c(#\"#EDEFEE\", # Paper\n  \"#1A8BB3\", # Teal - no longer teal, just bright blue\n  \"#0950AE\", # Dark blue\n  \"#4DACE5\", # Light blue\n  \"#126DDB\", # Blue\n  \"#E48DC4\", # Pink\n  \"#ABA9E8\", # Light purple\n  \"#872791\", # Purple\n  \"#6D1617\", # Dark red\n  \"#B81634\", # Red\n  \"#DF3B43\", # Red orange\n  \"#E35C47\", # Orange\n  \"#EB8749\", # Light orange\n  \"#F6E254\", # Yellow\n  \"#7B442D\", # Brown\n  \"#000000\", # Black\n  \"#1A6E7E\", # Dark green - no longer dark green, now looks teal\n  \"#7CBF7B\", # Green\n  \"#ADD2B8\") # Light green\n\n# End user parameters\n\n# Generate the color vector\ncolor_vector <- get_color_vector(size, colors)\n\n# Create a data frame for the grid coordinates\ndf <- expand.grid(x = 1:size, y = 1:size)\n\n# Add the corresponding color to each grid cell coordinate\ndf$color <- color_vector\n\n# Get the probability vector\nprob_vector <- get_prob_vector(circuits)\n\n# Assign probabilities to matrix correctly\nM <- get_prob_matrix(size, prob_vector)\n\n# Apply prob matrix M to df as a vector\ndf$probs <- as.vector(M)\n\ndf <- get_kelly_III_vector(df, background)\n\n# Try the plot\nkelly_colors_III <-\n  ggplot(df, aes(x = x, y = y, fill = color)) +\n  geom_tile() +  # Add tiles\n  scale_fill_identity() +  # Use the colors stored as strings in the color column\n  theme_void() +  # Remove axis labels and background\n  coord_equal()  # Use equal aspect ratio\n\n# Print the plot\nkelly_colors_III\n```\n:::\n\n\n\nNext targets:\n\n- organize code  \n- figure out if I want to offer a background option as a toggle, but label it clearly as reproducing a specific piece's style.  \n    - if white is chosen, its piece III and black gets included as a color, no blobs  \n    - if black is chosen, its piece IV, and the colors exclude white no blobs  \n    - also offer chance VII, full color dispersion, no white, includes black as a color, blobs ok  \n- write code for companion paint-by-numbers plot and swatch plot  \n    - need to assign each color a number and ensure that number gets plotted on the grid and on the swatch plot in association with the same colors. If â€œyellowâ€ is 3 on the paint by numbers plot, it should be 3 on the swatch plot.  \n- see if I can delineate what part of this, if any, could be useful as a blog series part 1. It would be focused on the planning and documenting of my process, not on the code. Not a tutorial, more of a documentary with commentary.  \n\n[**Note from Future Libby: Spoiler alert, you're reading the blog series now. Hilarious that I thought ALL of that so far would be a \"part 1\" of a blog series ðŸ˜‚ Here we are on part 6 because it's just so much. I'm surprised that I can follow everything still. Thank you, Past Libby, for being such a good comment-user and note-taker ðŸ˜ But, I'm guessing no one else will ever read this!**]  \n\nThanks for hanging out with my, if you're reading this. Here's a link to [the seventh part of these series](../2025-06-10_ellsworth-part-7/index.qmd), and here's [the app in its current form](https://libbyheeren-ellsworth.share.connect.posit.cloud/) if you'd like to play with it!.  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}